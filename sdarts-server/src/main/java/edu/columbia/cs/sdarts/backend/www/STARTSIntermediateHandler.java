package edu.columbia.cs.sdarts.backend.www;

import java.util.Vector;

import org.xml.sax.AttributeList;
import org.xml.sax.SAXException;

import edu.columbia.cs.sdarts.common.LSPDoc;
import edu.columbia.cs.sdarts.common.LSPField;
import edu.columbia.cs.sdarts.common.LSPModifier;
import edu.columbia.cs.sdarts.common.LSPSource;
import edu.columbia.cs.sdarts.common.LSPTerm;
import edu.columbia.cs.sdarts.util.HTTPGet;
import edu.columbia.cs.sdarts.util.HTTPPost;
import edu.columbia.cs.sdarts.util.HTTPRequest;
import edu.columbia.cs.sdarts.util.IntStack;
import edu.columbia.cs.sdarts.util.SDARTSHandlerBase;
import edu.columbia.cs.sdarts.util.UnsynchStack;

/**
 * A SAX <code>DocumentHandler</code> that knows how to process
 * <code>starts_intermediate</code> XML. It receives the XML as
 * SAX events. When it is done processing, it will have one or both
 * of the following available:
 * <ul>
 * <li>A collection of {@link edu.columbia.cs.sdarts.common.LSPDoc LSPDocs}
 * <li>An {@link edu.columbia.cs.sdarts.util.HTTPRequest HTTPRequest}
 * </ul>
 * This class is used by both the
 * {@link edu.columbia.cs.sdarts.backend.www.WWWQueryTranslator WWWQueryTranslator} and the
 * {@link edu.columbia.cs.sdarts.backend.www.WWWSession WWWSession}. When the
 * <code>WWWQueryTranslator</code> uses it, the translator is sending it
 * SAX events generated by the XSL transformation of an
 * {@link edu.columbia.cs.sdarts.common.LSPQuery LSPQuery} into the
 * <code>starts_intermediate</code> form. In this case, the only thing
 * produced is an <code>HTTPRequest</code>. When the
 * <code>WWWSession</code> uses it, the session is sending it SAX events
 * generated by the XSL transformation of an HTML results page into the
 * <code>starts_intermediate</code> form. In this case, there should
 * hopefully be <code>LSPDocs</code> available. In addition, if there
 * was a "more" button at the bottom of the results page, and the
 * <code>www_results.xsl</code> stylesheet was written to find this
 * button and turn it into a <code>starts_intermediate</code>
 * &lt;starts:script&gt;, then a new <code>HTTPRequest</code> will also be
 * available.
 * <p>
 * When interpreting query results, the <code>STARTSIntermediateHandler</code>
 * is initialized with the set of {@link edu.columbia.cs.sdarts.common.LSPField LSPFields}
 * used in the "answer-fields" portion of the query, and it automatically
 * puts only those fields into the <code>LSPDocs</code>; so there is no need
 * to try and do this in the <code>www_results.xsl</code> stylesheet. That
 * file should focus only on the filter and ranking portions of the query.
 * <p>
 * A new instance of this class should be created each time it is used.
 * <p>
 * For more information about the <code>starts_intermediate</code>
 * format, see the
 * <a href="http://www.cs.columbia.edu/~dli2test/dtd/starts_interemdiate.dtd">
 * starts_intermediate.dtd</a>.
 * @author <a href="mailto:ngreen@cs.columbia.edu">Noah Green</a>
 * @author <i>modified by:</i> <a href="mailto:ss1792@cs.columbia.edu">Sergey Sigelman</a>
 * @author <i>modified by:</i> <a href="jb605@cs.columbia.edu">Jiangcheng Bao</a>
 * @version 1.0
 */
public class STARTSIntermediateHandler extends SDARTSHandlerBase {
	private IntStack state;
	private static final int UNKNOWN = -1;
	private static final int INTERMEDIATE = 0;
	private static final int SQRDOCUMENT = 1;
	private static final int RAWSCORE = 2;
	private static final int SOURCE = 3;
	private static final int DOC_TERM = 4;
	private static final int FIELD = 5;
	private static final int VALUE = 6;
	private static final int TERM_STATS_LIST = 7;
	private static final int TERM = 8;
	private static final int MODIFIER = 9;
	private static final int TERM_FREQ = 10;
	private static final int TERM_WEIGHT = 11;
	private static final int DOC_FREQ = 12;
	private static final int DOCSIZE = 13;
	private static final int DOCCOUNT = 14;
	private static final int SCRIPT = 15;
	private static final int URL = 16;
	private static final int VARIABLE = 17;
	private static final int NAME = 18;
	private static final int NUM_AVAILABLE = 19;

	// Storage for LSPDoc
	private LSPDoc doc;
	private UnsynchStack docs = new UnsynchStack();
	private LSPField field;
	private String fieldValue;
	private LSPTerm term;
	private UnsynchStack modifiers = new UnsynchStack();
	private int termFreq;
	private double termWeight;
	private int docFreq;
	private LSPField[] answerFields;

	// Storage for script
	private Vector requests;
	/* change params to vector, in order to have multiple value of same name
	   also in order to keep order
	private Map params;
	*/
	private Vector params;
	private String url;
	private String method;
	private String varName;
	private String varValue;

	// Storage for both
	private StringBuffer valBuff;

	// Storage for total available nuber of documents
	private int numavailable;

	/**
	 * Create a new instance without any knowledge of "answer-fields".
	 * This is generally used for query translation.
	 */
	public STARTSIntermediateHandler() throws SAXException, javax.xml.parsers.ParserConfigurationException {
		EnableValidation(true);
		EnableSchemaChecking(true);

		requests = new Vector();
		params = new Vector();
		state = new IntStack();
		valBuff = new StringBuffer();
		state.push(UNKNOWN);
	}

	/**
	 * Create an instance that knows what "answer-fields" should appear in
	 * the results. This is generally used for results translation.
	 * @param answerFields the answer fields
	 */
	public STARTSIntermediateHandler(LSPField[] answerFields)
		throws SAXException, javax.xml.parsers.ParserConfigurationException {
		this();
		this.answerFields = answerFields;
	}

	/**
	 * After this class is done processing, this should return any
	 * <code>LSPDocs</code> created in the translation
	 * @return any
	 * <code>LSPDocs</code> created in the translation
	 */
	public LSPDoc[] getDocs() {
		return (LSPDoc[])docs.toArray(new LSPDoc[0]);
	}

	/**
	 * After this class is done processing, this should return an
	 * <code>HTTPRequest</code> created in the translation
	 * @return an
	 * <code>HTTPRequest</code> created in the translation
	 */
	public HTTPRequest getRequest() {
		HTTPRequest request = null;
		if ((requests != null) && (requests.size() > 0)) {
			request = (HTTPRequest)requests.elementAt(0);
			requests.removeElementAt(0);
		}
		return request;
	}

	/**
	 * @return number of requests left
	 */
	public int getRequestCount() {
		if (requests == null) {
			return 0;
		} else {
			return requests.size();
		}
	}

	/**
	 * Clear the state of the handler. This makes the handler reusable,
	 * but really only for query translation. Results translation depends
	 * on the "answer-fields" property having been set in the constructor
	 */
	public void clear() {
		valBuff.setLength(0);
		state.clear();
		doc = null;
		docs.clear();
		field = null;
		fieldValue = null;
		term = null;
		modifiers.clear();
		termFreq = -1;
		termWeight = -1;
		docFreq = -1;
		params.clear();
		url = null;
		method = null;
		varName = null;
		varValue = null;
		numavailable = 0;
	}

	/**
	 * Part of SAX API, do not call
	 */
	public void startElement(String name, AttributeList attrs) throws SAXException {
		int previousState = state.peek();
		name = this.removeNamespace(name);

		if (name.equals("intermediate")) {
			state.push(INTERMEDIATE);
		} else if (name.equals("sqrdocument")) {
			state.push(SQRDOCUMENT);
			doc = new LSPDoc();
		} else if (name.equals("rawscore")) {
			state.push(RAWSCORE);
		} else if (name.equals("source")) {
			state.push(SOURCE);
		} else if (name.equals("doc-term")) {
			state.push(DOC_TERM);
		} else if (name.equals("field")) {
			LSPField temp = new LSPField(attrs.getValue("name"));

			if (previousState == DOC_TERM) {
				field = temp;
			} else if (previousState == TERM) {
				term.setField(temp);
			} else {
				processException("illegal field location");
			}
			state.push(FIELD);
		} else if (name.equals("value")) {
			state.push(VALUE);
		} else if (name.equals("term-stats-list")) {
			state.push(TERM_STATS_LIST);
		} else if (name.equals("term")) {
			state.push(TERM);
			term = new LSPTerm();
		} else if (name.equals("modifier")) {
			state.push(MODIFIER);
			modifiers.push(new LSPModifier(attrs.getValue("name")));
		} else if (name.equals("term-freq")) {
			state.push(TERM_FREQ);
		} else if (name.equals("term-weight")) {
			state.push(TERM_WEIGHT);
		} else if (name.equals("doc-freq")) {
			state.push(DOC_FREQ);
		} else if (name.equals("docsize")) {
			state.push(DOCSIZE);
		} else if (name.equals("doccount")) {
			state.push(DOCCOUNT);
		} else if (name.equals("script")) {
			state.push(SCRIPT);
		} else if (name.equals("url")) {
			method = attrs.getValue("method").toUpperCase();
			state.push(URL);
		} else if (name.equals("variable")) {
			state.push(VARIABLE);
		} else if (name.equals("name")) {
			state.push(NAME);
		} else if (name.equals("value")) {
			state.push(VALUE);
		} else if (name.equals("numavailable")) {
			state.push(NUM_AVAILABLE);
		} else {
			this.processException("unknown element: " + name);
		}
	}

	/**
	 * Part of SAX API, do not call
	 */
	public void characters(char[] ch, int start, int end) throws SAXException {
		String val = new String(ch, start, end).trim();
		int currentState = state.peek();
		int previousState = state.peek(1);

		switch (currentState) {
			case RAWSCORE :
				doc.setRawScore(new Double(val).doubleValue());
				break;

			case SOURCE :
				doc.addSource(new LSPSource(val));
				break;

			case VALUE :
				valBuff.append(val.trim());
				// why is it here?
				// i'm removing this line because it screws up the results
				// by making xml not well-formed.  Alex (07/28/03)
				// valBuff.append (" ");
				break;

			case TERM_FREQ :
				termFreq = new Integer(val).intValue();
				break;

			case TERM_WEIGHT :
				termWeight = new Double(val).doubleValue();
				break;

			case DOC_FREQ :
				docFreq = new Integer(val).intValue();
				break;

			case DOCSIZE :
				doc.setDocSize(new Integer(val).intValue());
				break;

			case DOCCOUNT :
				doc.setDocCount(new Integer(val).intValue());
				break;

			case URL :
				url = val;
				break;

			case NAME :
				varName = val;
				break;

			case NUM_AVAILABLE :
				numavailable = new Integer(val).intValue();
				break;
		}
	}

	/**
	 * Part of SAX API, do not call
	 */
	public void endElement(String name) throws SAXException {
		int currentState = state.peek();
		int previousState = state.peek(1);
		switch (currentState) {
			case SQRDOCUMENT :
				docs.push(doc);
				doc = null;
				break;

			case DOC_TERM :
				if (checkField(field)) {
					doc.addFieldValue(field, fieldValue);
				}
				field = null;
				fieldValue = null;
				break;

			case TERM :
				if (modifiers.size() != 0) {
					term.setModifiers((LSPModifier[])modifiers.toArray(new LSPModifier[0]));
					modifiers.clear();
				}
				break;

			case VALUE :
				String val = valBuff.toString().trim();
				if (previousState == DOC_TERM) {
					fieldValue = val;
				} else if (previousState == VARIABLE) {
					varValue = val;
				} else if (previousState == TERM) {
					term.setValue(val);
				} else {
					processException("illegal <value> state");
				}
				valBuff.setLength(0);
				break;

			case DOC_FREQ :
				doc.addTermStat(term, termFreq, termWeight, docFreq);
				term = null;
				termFreq = -1;
				termWeight = -1;
				docFreq = -1;
				break;

			case VARIABLE :
				/* add this name/value pair into the vector pair
				 */
				String[] s = new String[2];
				s[0] = varName;
				s[1] = varValue;
				params.addElement(s);
				varName = null;
				varValue = null;
				break;

			case SCRIPT :
				try {
					if (method.equals("GET")) {
						HTTPRequest request = new HTTPGet(url, params);
						requests.addElement(request);
					} else if (method.equals("POST")) {
						HTTPRequest request = new HTTPPost(url, params);
						requests.addElement(request);
					} else {
						throw new SAXException("illegal method: " + method);
					}
				} catch (Exception e) {
					throw new SAXException(e.getMessage());
				}
				url = null;
				params.clear();
				method = null;
				break;
		}

		state.pop();
	}

	private boolean checkField(LSPField field) {
		if (answerFields == null)
			return true;
		int len = answerFields.length;

		boolean foundMatch = false;
		for (int i = 0; i < len; i++) {
			if (field.equals(answerFields[i])) {
				foundMatch = true;
				break;
			}
		}
		return foundMatch;
	}

	public int getNumAvailable() {
		return numavailable;
	}

}
